# c++基础知识
已完成：
- struct和union
- struct和class
- malloc/free和new/delete
- STL
- 智能指针

---
## struct和union
1.	共用体和结构体都是由多个不同的数据类型成员组成， 但在任何同一时刻， 共用体只存放一个被选中的成员， 而结构体则存放所有的成员变量。对于共用体的不同成员赋值，将会对其他成员重写， 原来成员的值就不存在了， 而对于结构体的不同成员赋值是互不影响的。
2.	内存分配不同：union的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小。struct的大小和顺序、对齐有关。
3.  从c语言的角度来看, union是对一片内存的不同解读方式。

## struct和class
C++中的struct对C中的struct进行了扩充。struct可以包含成员函数，可以继承，可以实现多态。
区别：
1.	默认的继承访问权限 struct是public的，class是private的，取决于子类而不是基类。
2.	“class”这个关键字还用于定义模板参数，就像“typename”。但关键字“struct”不用于定义模板参数。这一点在Stanley B.Lippman写的Inside the C++ Object Model有过说明。
当你觉得你要做的更像是一种数据结构的话，那么用struct，如果你要做的更像是一种对象的话，那么用class。struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。

## malloc/free和new/delete
1.	从功能来说，malloc和new用于申请内存，free和delete用于释放内存。
2.	从底层来说，需要站在计算机系统层面。分申请和释放两大类来谈。申请内存空间先说malloc，malloc的底层原理是通过brk和mmap系统调用申请堆空间的一块内存。
### malloc和new的区别
从功能上：
1.	申请的内存位置不同。malloc从堆上申请,new可以从堆上申请也可以从其他地方比如静态存储区,C++中的概念叫自由存储区。
2.	返回类型的安全性不同。new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
3.	分配失败时的返回值不同。new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。
4.	是否需要指定内存大小。new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。
5.	是否调用构造函数/析构函数。
6.	对数组的处理。
7.	依赖关系。
8.	是否可以重载。
9.	是否可以直观地重新分配内存。
10.	是否能重新分配内存。客户处理内存分配不足
上边说了十点区别，看似逻辑性不强，我觉得一些应用上的区别一定都是系统级或者说是底层的一种具象的反映。如果了解new和malloc的源码，就掌握了根本区别。
从底层实现上：我们可以参考malloc和new的源码：
- 待补充


## STL
STL是C++的标准模板库，是一个封装良好，复用性强的库/软件系统。以下简单介绍它提供的Service，对外暴露的Interface以及各组件的Implementation

### Service
提供一系列低耦合，复用性强的数据结构和算法

### Interface

主要是通过泛型编程，直接实例化使用容器/配接器的function member，把迭代器视为“指针”，通用算法通过迭代器对容器进行操作。以此达到“利用各种算法操作数据结构”的Service。

### Implementation

STL由六大部分组成：
- allocator：空间配置器，用来为所有数据结构分配并管理空间。
- iterator：迭代器，用来封装“指针”，提供通用的类指针功能。
- container：容器，各种数据结构，分为序列式和关联式。序列式有vector, list, deque, stack, queue(stack和queue是由deque而来)等等，关联式有set, map, multi系列，hash系列等等。
- algorithm：算法，各种通用性算法，容器和算法之间通过迭代器结合使用。
- functor：仿函数/函数对象，像函数一样的对象。
- adapter：配接器，STL各个组件的转换器，常用于转换接口。常见的stack和queue其实底层都是通过配接deque实现的。

六大组件的关系：allocator为所有数据结构分配并管理空间，container提供了各种各种的数据结构，这些数据结构本身有一些function member。我们可以通过迭代器去操作容器元素，也可以用迭代器去和某种算法连接，从而修改容器。而仿函数/函数对象充当了一个行为类似函数的对象，配接器为其他STL组件提供了灵活的接口。

具体的实现，可以学习侯捷的《STL源码剖析》（SGI版本）和STL的一些复现。

## 智能指针
auto_ptr、unique_ptr、shared_ptr 和 weak_ptr 其中auto_ptr在C++11中被摒弃




